lines(0:100,fit.loess, col="blue",lwd=2)
lines(0:100,fit.loess, col="blue",lwd=2)
lines(0:100,fit.loess, col="blue",lwd=1)
legend("topleft", legend = c("m1", "m2", "m.loess"), col = c( "green","red", "blue")) #we can add line type  lty = 1:3
legend("topleft", legend = c("m1", "m2", "m.loess"), col = c( "green","red", "blue"))
line
cholost<- read.csv("C:/Users/fairouz/Desktop/Masters/Y2-S1/Statistical methods/cholost.csv")
str(cholost)
plot(cholost, xlab= "copliance", ylab= "imprvement")
abline(h=0)
x<- cholost[,1]
y<-cholost[,2]
ls()
m1<- lm(y~x)
m1=lm(y~x)
par(mfrow=c(2,2))
plot(m1)
par(mfrow=c(1,1))
plot(cholost,xlab="complaince",ylab="improvement")
lines(0:100,predict(m1,newdata=data.frame(x=0:100)),col="green")
#we are using the lm model m1 to predict the y values for the x values generated as a sequence from 1 to 100
m2<- lm(y~x+I(x^2))
summary(m2)
m2b<-lm(y~poly(x,degree=2))
summary(m2b)
dev.new()
par(mfrow=c(2,2))
plot(m2)
plot(m2b)
dev.set()
#lines(0:100,predict(m2,newdata=data.frame(x=0:100)))
lines(0:100,predict(m2,newdata=data.frame(x=0:100)),col="red")
lines(0:100,predict(m2b,newdata=data.frame(x=0:100)),col="green")
#the 2 models are exactly the same since we observe that the 2 lines are the same
m.loess<-loess(y~x,span=0.3)#we need a smoothing parameter, the smaller this number the rougher the curve , the bigger the number, the smoother the curve
summary(m.loess)
fit.loess<- predict(m.loess,newdata = data.frame(x=0:100))
str(fit.loess)
lines(0:100,fit.loess, col="blue",lwd=1)
legend("topleft", legend = c("m1", "m2", "m.loess"), col = c( "green","red", "blue")) #we can add line type  lty = 1:3
#lines(0:100,predict(m2,newdata=data.frame(x=0:100)))
lines(0:100,predict(m2,newdata=data.frame(x=0:100)),col="red")
legend("topleft", legend = c("m1", "m2", "m.loess"), col = c( "green","red", "blue"),lty=1) #we can add line type  lty = 1:3
par(mfrow=c(1,1))
scatter.plot(x,y,span=0.3,xlab="compliance,ylab="improvement")
scatter.smooth(x,y,span=0.3,xlab="compliance,ylab="improvement")
scatter.smooth(x,y,span=0.3,xlab="compliance", ylab="improvement")
abline(v=60)
abline(v=60,col=1)
abline(v=80,col=2)
abline(v=100,col=5)
abline(v=60,col=4)
abline(v=80,col=5)
abline(v=100,col=6)
fit.loess<-predict(m.loess,newdata = data.frame(x=c(60,80,100)))
fir.loess
fit.loess
theta,loess<- (fit.loess[3]-fit.loess[2])/20 - (fit.loess[2]-fit.loess[2])/20
theta.loess<- (fit.loess[3]-fit.loess[2])/20 - (fit.loess[2]-fit.loess[2])/20
theta.loess
theta.loess<- (fit.loess[3]-fit.loess[2])/20 - (fit.loess[2]-fit.loess[1])/20
theta.loess
fit.quad<-predict(m2,newdata = data.frame(x=c(60,80,100)))
fit.loess
theta.quad<- (fit.quad[s3]-fit.quad[2])/20 - (fit.quad[2]-fit.quad[1])/20
theta.quad
fit.quad
theta.quad<- (fit.quad[s3]-fit.quad[2])/20 - (fit.quad[2]-fit.quad[1])/20
theta.quad<- (fit.quad[3]-fit.quad[2])/20 - (fit.quad[2]-fit.quad[1])/20
theta.quad
n<- length(x)
nboot<- 100
pred,loess<- matrix(NA,nboot,3)
pred,quad<- matrix(NA,nboot,3)
pred.quad<- matrix(NA,nboot,3)
set.seed(999)
k.star<- sample(n,replace = TRUE)
plot(x,y,xlab="compliance", ylab="improvement")
title("loess")
lines(c(0,1),predict(m.loess,newdata=data.frame(x=0:100))
plot(x,y,xlab="compliance", ylab="improvement")
title("loess")
lines(c(0,1),predict(m.loess,newdata=data.frame(x=0:100))
set.seed(999)
lines(c(0,1),predict(m.loess,newdata=data.frame(x=0:100)))
set.seed(999)
lines(0:100,predict(m.loess,newdata=data.frame(x=0:100)))
set.seed(999)
lines(0:100,predict(m2,newdata = data.frame(x=0:100)),lwd=4)
for(1 in 1:nboot){
k.star<- sample(n,replace = TRUE)
x.star<-x[k.star]
y.star<-y[k.star]
out.star<-loess(y.star~x.star,span=0.3,degree=1)
dev.set()
curve(predict(out.star,data.frame(x.star=x)), add= TRUE, col="turquoise")
pred.loess[i,]<- predict(out.star,newdata=data.frame(x.star=c(60,80,100)))
#
out.q.star<- lm(y.star~x.star +I(x.star^2))
dev.set()
curve(predict(out.q.star,data.frame(x.star=x)), add= TRUE, col= 'turquoise')
pred.quad[i,]<- predict(out.q.star,newdata=data.frame(x.star=c(60,80,100)))
}
lines(0:100,predict(m2,newdata = data.frame(x=0:100)),lwd=4)
dev.set()
lines(0:100,predict(m.loess,newdata = data.frame(x=0:100)),lwd=4)
lines(0:100,predict(m.loess,newdata = data.frame(x=0:100)),lwd=2)
lines(0:100,predict(m2,newdata = data.frame(x=0:100)),lwd=2)
dev.set()
lines(0:100,predict(m.loess,newdata = data.frame(x=0:100)),lwd=2)
plot(x,y,xlab="compliance", ylab="improvement")
title("loess")
lines(0:100,predict(m.loess,newdata=data.frame(x=0:100)))
set.seed(999)
for(1 in 1:nboot){
k.star<- sample(n,replace = TRUE)
x.star<-x[k.star]
y.star<-y[k.star]
out.star<-loess(y.star~x.star,span=0.3,degree=1)
dev.set()
curve(predict(out.star,data.frame(x.star=x)), add= TRUE, col="turquoise")
pred.loess[i,]<- predict(out.star,newdata=data.frame(x.star=c(60,80,100)))
#
out.q.star<- lm(y.star~x.star +I(x.star^2))
dev.set()
curve(predict(out.q.star,data.frame(x.star=x)), add= TRUE, col= 'turquoise')
pred.quad[i,]<- predict(out.q.star,newdata=data.frame(x.star=c(60,80,100)))
}
lines(0:100,predict(m2,newdata = data.frame(x=0:100)),lwd=2)
dev.set()
lines(0:100,predict(m.loess,newdata = data.frame(x=0:100)),lwd=2)
plot(x,y,xlab="compliance", ylab="improvement")
title("loess")
lines(0:100,predict(m.loess,newdata=data.frame(x=0:100)))
set.seed(999)
for(i in 1:nboot){
k.star<- sample(n,replace = TRUE)
x.star<-x[k.star]
y.star<-y[k.star]
out.star<-loess(y.star~x.star,span=0.3,degree=1)
dev.set()
curve(predict(out.star,data.frame(x.star=x)), add= TRUE, col="turquoise")
pred.loess[i,]<- predict(out.star,newdata=data.frame(x.star=c(60,80,100)))
#
out.q.star<- lm(y.star~x.star +I(x.star^2))
dev.set()
curve(predict(out.q.star,data.frame(x.star=x)), add= TRUE, col= 'turquoise')
pred.quad[i,]<- predict(out.q.star,newdata=data.frame(x.star=c(60,80,100)))
}
lines(0:100,predict(m2,newdata = data.frame(x=0:100)),lwd=2)
dev.set()
lines(0:100,predict(m.loess,newdata = data.frame(x=0:100)),lwd=2)
for(i in 1:nboot){
k.star<- sample(n,replace = TRUE)
x.star<-x[k.star]
y.star<-y[k.star]
out.star<-loess(y.star~x.star,span=0.3,degree=1)
dev.set()
curve(predict(out.star,data.frame(x.star=x)), add= TRUE, col="turquoise")
pred.loess[i,]<- predict(out.star,newdata=data.frame(x.star=c(60,80,100)))
#
out.q.star<- lm(y.star~x.star +I(x.star^2))
dev.set()
curve(predict(out.q.star,data.frame(x.star=x)), add= TRUE, col= 'turquoise')
pred.quad[i,]<- predict(out.q.star,newdata=data.frame(x.star=c(60,80,100)))
}
mean.loess<-apply(pred.loess,2,mean)
se,loess<- apply(pred.loess,2,sd)
se.quad<- apply(pred.quad,2,sd)
mean.quad<- apply(pred.quad,2,mean)
mean.loess
mean.quad
theta<- (pred.loess[,3]~pred.loess[,2])/20- (pred.loess[,3]~pred.loess[,1])/20
load("C:/Users/fairouz/Desktop/Masters/Y2-S1/Statistical methods/lab3/InternetAd.RData")
load("C:/Users/fairouz/Desktop/Masters/Y2-S1/Statistical methods/lab3/hiv.rda")
hiv.test
InternetAd
# Project
rm(list = ls())
# Import libraries
library(dplyr)
library(ggplot2)
# Project
rm(list = ls())
# Import libraries
library(dplyr)
library(ggplot2)
# Project
rm(list = ls())
# Import libraries
library(dplyr)
library(ggplot2)
install.packages("ggplot2")
install.packages("ggplot2")
install.packages(c("gtable", "lifecycle", "rlang", "scales", "vctrs"))
library(ggplot2)
library(dplyr)
rm(list = ls())
# Import libraries
library(dplyr)
library(ggplot2)
# Load the data
data_raw = read.csv('/home/theresa/Schreibtisch/Theresa/STUDIUM/Master Statistics and Data Science/Padova/Statistical Methods for High-Dim Data/Project/Data/titles.csv', header = TRUE)
# Load the data
data_raw = read.csv('C:/Users/fairouz/Desktop/statistical method project/titles.csv', header = TRUE)
data_raw = data_raw %>%
# remove redundant id variables
select(-c(id,imdb_id)) %>%
# remove movies/films with no genre, country and year
filter(genres !='[]' & production_countries != '[]') %>%
# transform variables into factors
mutate(type = as.factor(type),
age_certification = as.factor(age_certification)) %>%
# extract genre as binary features
mutate(drama = ifelse(grepl('drama',genres), 1, 0),
comedy = ifelse(grepl('comedy',genres), 1, 0),
documentation = ifelse(grepl('documentation',genres), 1, 0),
horror = ifelse(grepl('horror',genres), 1, 0),
crime = ifelse(grepl('crime',genres), 1, 0),
action = ifelse(grepl('action',genres), 1, 0),
thriller = ifelse(grepl('thriller',genres), 1, 0),
fantasy = ifelse(grepl('fantasy',genres), 1, 0),
romance = ifelse(grepl('romance',genres), 1, 0),
history = ifelse(grepl('history',genres), 1, 0),
scifi = ifelse(grepl('scifi',genres), 1, 0),
animation = ifelse(grepl('animation',genres), 1, 0),
reality = ifelse(grepl('reality',genres), 1, 0),
sport = ifelse(grepl('sport',genres), 1, 0),
family = ifelse(grepl('family',genres), 1, 0),
music = ifelse(grepl('music',genres), 1, 0),
war = ifelse(grepl('war',genres), 1, 0),
western = ifelse(grepl('western',genres), 1, 0))
head(data_raw)
## First impressions
# Release year
hist(data_raw$release_year, breaks = c(1945:2022), xlab = 'Year of Release', main = 'Year of release for movies and shows')
# Types
table(data_raw$type)
boxplot(data_raw[data_raw$type == 'MOVIE',]$runtime, xlab = 'Movies', ylab = 'run time', ylim = c(0,250))
boxplot(data_raw[data_raw$type == 'SHOW',]$runtime, xlab = 'Shows', ylab = 'run time', ylim = c(0,250))
par(mfrow = c(1,1))
# Genres
column_sums <- colSums(data_raw[, c(14:31)])
plot_data <- data.frame(
column_names = names(column_sums),
column_sums = column_sums
)
plot_data$column_names <- reorder(plot_data$column_names, -plot_data$column_sums)
ggplot(plot_data, aes(x = column_names, y = column_sums)) +
geom_bar(stat = "identity", fill = "skyblue", color = "black") +
labs(x = "Genre", y = "Number of movies/shows") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) + ggtitle('Distribution of genres')
head(column_sums)
# Genres
typeof(column_sums)
typeof(column_sums)
# Genres
column_sums <- colSums(data_raw[, c(14:31)])
class(column_sums)
head(plot_data)
vec <- c(a = 10, b = 20, c = 30)
vec
names(vec)=c(A,B,C,D)
new_order <- c("c", "a", "b")
renamed_vec <- vec[new_order]
vec
renamed_vec
names(vec)= c("A","B","C")
vec
# Number of seasons for shows
hist(data_raw[data_raw$type == 'SHOW',]$seasons, breaks = c(1:43), xlab = 'Number of seasons', main = 'Number of seasons for shows')
data.frame(x=0:100)
data.frame(x=c(60,90,100))
# Import libraries
library(dplyr)
library(ggplot2)
# Load the data
data_raw = read.csv('C:/Users/fairouz/Desktop/statistical method project/titles.csv', header = TRUE)
View(data_raw)
View(data_raw)
### Import libraries
library(dplyr)
library(ggplot2)
library(ggrepel)
library(cowplot)
library(glmnet)
library(gridExtra)
library(e1071)
### Load the data
user = 'Fairouz'
if (user == 'Mattia'){
setwd("/Users/mattiapiazza/Documents/University/Statistical Methods for High Dimensional Data/Project/Dataset")
}
if (user == 'Theresa'){
setwd("/home/theresa/Schreibtisch/Theresa/STUDIUM/Master Statistics and Data Science/Padova/Statistical Methods for High-Dim Data/Project/Data")
}
if (user == 'Fairouz'){
setwd("C:/Users/fairouz/Desktop/statistical method project/dataset")
}
data_raw = read.csv('titles.csv', header = TRUE)
credits = read.csv("credits.csv", header=TRUE)
data_show= read.csv('data_show.csv', header = TRUE)
data_movie = read.csv("data_movie.csv", header=TRUE)
# Remove rows with NA values from the dataset
data_movie <- na.omit(data_movie)
data_show <- na.omit(data_show)
###SVR without scaling
##test-train split
set.seed(1234)
data_movie_num <- data_movie %>% select(-c("X","title","description","genres","production_countries","type"))
data_show_num <- data_show %>% select(-c("X","title","description","genres","production_countries","type"))
random <- sample(1:nrow(data_movie_num), ceiling(0.8*dim(data_movie_num)[1]))
train_movie <- data_movie_num[random,]
test_movie <- data_movie_num[-random,]
X_train_movie<- select(train_movie ,-c(imdb_score))
y_train_movie<- train_movie$imdb_score
X_test_movie<- select(test_movie ,-c(imdb_score))
y_test_movie<- test_movie$imdb_score
random <- sample(1:nrow(data_show_num), ceiling(0.8*dim(data_show_num)[1]))
train_show <- data_show_num[random,]
test_show <- data_show_num[-random,]
X_train_show<- select(train_show ,-c(imdb_score))
y_train_show<- train_show$imdb_score
X_test_show<- select(test_show ,-c(imdb_score))
y_test_show<- test_show$imdb_score
##FOR MOVIES
#without tmdb scores and popularity
SVR_movie <- svm(imdb_score~release_year + age_certification + runtime + imdb_votes +
isNotUS + drama + comedy + documentation + horror + crime +
action + thriller + fantasy + romance + history + scifi +
animation + reality + sport + family + music + war + western, data = train_movie , kernel = "radial", type = "nu-regression", epsilon = 0.1, cost = 2, gamma = 0.03)
SVR_pred_movie <- predict(SVR_movie, X_test_movie)
# Calculate MSE (Mean Squared Error)
SVR_movie_mse <- mean((SVR_pred_movie - y_test_movie)^2)
#~0.8469
#visualize
# Create a data frame with true and predicted values
plot_data <- data.frame(Actual = y_test_movie, Predicted = SVR_pred_movie)
# Scatter plot
ggplot(plot_data, aes(x = Actual, y = Predicted)) +
geom_point(color = "blue") +
geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "red") +  # Add a line of perfect prediction
labs(x = "True IMDb Scores", y = "Predicted IMDb Scores") +
ggtitle("SVR Predictions vs. True Values for movies without tmdb ")
#the model did not predict the lower values well
#the red line is the x=y which is the perfect prediction
#with tmdb
SVR_movie2 <- svm(imdb_score~release_year + age_certification + runtime + imdb_votes + tmdb_score + tmdb_popularity +
isNotUS + drama + comedy + documentation + horror + crime +
action + thriller + fantasy + romance + history + scifi +
animation + reality + sport + family + music + war + western, data = train_movie , kernel = "radial", type = "nu-regression", epsilon = 0.1, cost = 2, gamma = 0.03)
SVR_pred_movie2 <- predict(SVR_movie2, X_test_movie)
# Calculate MSE (Mean Squared Error)
SVR_movie_mse2 <- mean((SVR_pred_movie2 - y_test_movie)^2)
#~0.5459
#visualize
# Create a data frame with true and predicted values
plot_data2 <- data.frame(Actual = y_test_movie, Predicted = SVR_pred_movie2)
# Scatter plot
ggplot(plot_data2, aes(x = Actual, y = Predicted)) +
geom_point(color = "blue") +
geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "red") +  # Add a line of perfect prediction
labs(x = "True IMDb Scores", y = "Predicted IMDb Scores") +
ggtitle("SVR Predictions vs. True Values for movies with tmdb")
##FOR SHOWS
#without tmdb scores and popularity
SVR_show <- svm(imdb_score~release_year + age_certification + runtime + imdb_votes + seasons+
isNotUS + drama + comedy + documentation + horror + crime +
action + thriller + fantasy + romance + history + scifi +
animation + reality + sport + family + music + war + western, data = train_show , kernel = "radial", type = "nu-regression", epsilon = 0.1, cost = 2, gamma = 0.03)
SVR_pred_show<- predict(SVR_show, X_test_show)
# Calculate MSE (Mean Squared Error)
SVR_show_mse <- mean((SVR_pred_show - y_test_show)^2)
#visualize
# Create a data frame with true and predicted values
plot_data3 <- data.frame(Actual = y_test_show, Predicted = SVR_pred_show)
# Scatter plot
ggplot(plot_data3, aes(x = Actual, y = Predicted)) +
geom_point(color = "purple") +
geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "green") +  # Add a line of perfect prediction
labs(x = "True IMDb Scores", y = "Predicted IMDb Scores") +
ggtitle("SVR Predictions vs. True Values for shows without tmdb")
#with tmdb
SVR_show2 <- svm(imdb_score~release_year + age_certification + runtime + seasons + imdb_votes + tmdb_score + tmdb_popularity +
isNotUS + drama + comedy + documentation + horror + crime +
action + thriller + fantasy + romance + history + scifi +
animation + reality + sport + family + music + war + western, data = train_show , kernel = "radial", type = "nu-regression", epsilon = 0.1, cost = 2, gamma = 0.03)
SVR_pred_show2 <- predict(SVR_show2, X_test_show)
# Calculate MSE (Mean Squared Error)
SVR_show_mse2 <- mean((SVR_pred_show2 - y_test_show)^2)
#visualize
# Create a data frame with true and predicted values
plot_data4 <- data.frame(Actual = y_test_show, Predicted = SVR_pred_show2)
# Scatter plot
ggplot(plot_data4, aes(x = Actual, y = Predicted)) +
geom_point(color = "purple") +
geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "green") +  # Add a line of perfect prediction
labs(x = "True IMDb Scores", y = "Predicted IMDb Scores") +
ggtitle("SVR Predictions vs. True Values for shows with tmdb")
#maybe because low scores have low number of votes and higher scores have higher number of votes and we're not scaling
##next maybe look more into interpretation of loess,
#changing parameters for svr to improve
#scaling before
###SVR with scaling
###Feature Scaling
#normalizing out data might improve the correlation matrix....It did not
# Scale feature values using min/max scaling
z_score_norm <- function(x) {
(x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)}
train_movie_scaled <-train_movie %>%
mutate_at(.vars = c(1,3,5,6,7), .funs = list(z_score_norm))
test_movie_scaled <-test_movie %>%
mutate_at(.vars = c(1,3,5,6,7), .funs = list(z_score_norm))
X_test_movie_scaled<- select(test_movie_scaled ,-c(imdb_score))
y_test_movie_scaled<- test_movie_scaled$imdb_score
train_show_scaled <-train_show %>%
mutate_at(.vars = c(1,3,4,6,7,8), .funs = list(z_score_norm))
test_show_scaled <-test_show %>%
mutate_at(.vars = c(1,3,4,6,7,8), .funs = list(z_score_norm))
X_test_show_scaled<- select(test_show_scaled ,-c(imdb_score))
y_test_show_scaled<- test_show_scaled$imdb_score
#the y test doesn't change so no need to define it again
#and we don;t really need x_train
##FOR MOVIES
#without tmdb scores and popularity
SVR_movie_scaled <- svm(imdb_score~release_year + age_certification + runtime + imdb_votes +
isNotUS + drama + comedy + documentation + horror + crime +
action + thriller + fantasy + romance + history + scifi +
animation + reality + sport + family + music + war + western, data = train_movie_scaled , kernel = "radial", type = "nu-regression", epsilon = 0.1, cost = 2, gamma = 0.03)
SVR_pred_movie_scaled <- predict(SVR_movie_scaled, X_test_movie_scaled)
# Calculate MSE (Mean Squared Error)
SVR_movie_mse_scaled <- mean((SVR_pred_movie_scaled - y_test_movie_scaled)^2)
#~0.8469
#visualize
# Create a data frame with true and predicted values
plot_data5 <- data.frame(Actual = y_test_movie_scaled, Predicted = SVR_pred_movie_scaled)
# Scatter plot
ggplot(plot_data5, aes(x = Actual, y = Predicted)) +
geom_point(color = "blue") +
geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "red") +  # Add a line of perfect prediction
labs(x = "True IMDb Scores", y = "Predicted IMDb Scores") +
ggtitle("SVR Predictions vs. True Values for movies, scaled without tmdb ")
#with tmdb
SVR_movie_scaled2 <- svm(imdb_score~release_year + age_certification + runtime + imdb_votes + tmdb_score + tmdb_popularity +
isNotUS + drama + comedy + documentation + horror + crime +
action + thriller + fantasy + romance + history + scifi +
animation + reality + sport + family + music + war + western, data = train_movie_scaled , kernel = "radial", type = "nu-regression", epsilon = 0.1, cost = 2, gamma = 0.03)
SVR_pred_movie_scaled2 <- predict(SVR_movie_scaled2, X_test_movie_scaled)
# Calculate RMSE (Root Mean Squared Error)
SVR_movie_mse_scaled2 <- mean((SVR_pred_movie_scaled2 - y_test_movie_scaled)^2)
#~0.5459
#visualize
# Create a data frame with true and predicted values
plot_data6 <- data.frame(Actual = y_test_movie_scaled, Predicted = SVR_pred_movie_scaled2)
# Scatter plot
ggplot(plot_data6, aes(x = Actual, y = Predicted)) +
geom_point(color = "blue") +
geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "red") +  # Add a line of perfect prediction
labs(x = "True IMDb Scores", y = "Predicted IMDb Scores") +
ggtitle("SVR Predictions vs. True Values for movies, scaled with tmdb")
##for shows
#without tmdb scores and popularity
SVR_show_scaled <- svm(imdb_score~release_year + age_certification + runtime + imdb_votes +
isNotUS + drama + comedy + documentation + horror + crime +
action + thriller + fantasy + romance + history + scifi +
animation + reality + sport + family + music + war + western, data = train_show_scaled , kernel = "radial", type = "nu-regression", epsilon = 0.1, cost = 2, gamma = 0.03)
SVR_pred_show_scaled <- predict(SVR_show_scaled, X_test_show_scaled)
# Calculate MSE (Mean Squared Error)
SVR_show_mse_scaled <- mean((SVR_pred_show_scaled - y_test_show_scaled)^2)
#~0.8469
#visualize
# Create a data frame with true and predicted values
plot_data7 <- data.frame(Actual = y_test_show_scaled, Predicted = SVR_pred_show_scaled)
# Scatter plot
ggplot(plot_data7, aes(x = Actual, y = Predicted)) +
geom_point(color = "purple") +
geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "green") +  # Add a line of perfect prediction
labs(x = "True IMDb Scores", y = "Predicted IMDb Scores") +
ggtitle("SVR Predictions vs. True Values for shows, scaled without tmdb ")
#with tmdb
SVR_show_scaled2 <- svm(imdb_score~release_year + age_certification + runtime + imdb_votes + tmdb_score + tmdb_popularity +
isNotUS + drama + comedy + documentation + horror + crime +
action + thriller + fantasy + romance + history + scifi +
animation + reality + sport + family + music + war + western, data = train_show_scaled , kernel = "radial", type = "nu-regression", epsilon = 0.1, cost = 2, gamma = 0.03)
SVR_pred_show_scaled2 <- predict(SVR_show_scaled2, X_test_show_scaled)
# Calculate MSE (Mean Squared Error)
SVR_show_mse_scaled2 <- mean((SVR_pred_show_scaled2 - y_test_show_scaled)^2)
#~0.5459
#visualize
# Create a data frame with true and predicted values
plot_data8 <- data.frame(Actual = y_test_show_scaled, Predicted = SVR_pred_show_scaled2)
# Scatter plot
ggplot(plot_data8, aes(x = Actual, y = Predicted)) +
geom_point(color = "purple") +
geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "green") +  # Add a line of perfect prediction
labs(x = "True IMDb Scores", y = "Predicted IMDb Scores") +
ggtitle("SVR Predictions vs. True Values for shows, scaled with tmdb")
#show is even worse with lower values bcz probably we have even a lower number of votings and shows
#the model does not improve much when we scale
#still doesn't predict lower values that well, probably because of lack of data
#use mattea's graph to explain
# IMDB sores (Movies + Shows)
#save results in dataframe
results <- data.frame(
with_scaling = c("No", "No","No", "No", "Yes", "Yes","Yes", "Yes"),
type = c("movie", "movie", "show", "show","movie", "movie", "show", "show"),
with_tmdb = c("no", "Yes", "no", "Yes","no", "Yes", "no", "Yes"),
mse = c(SVR_movie_mse,SVR_movie_mse2,SVR_show_mse,SVR_show_mse2,SVR_movie_mse_scaled,SVR_movie_mse_scaled2,SVR_show_mse_scaled,SVR_show_mse_scaled2))
View(results)
View(data_movie)
View(data_movie)
